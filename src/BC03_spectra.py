
# This program plots the BC03 spectra that are already stored under ./data/ according to a specified redshift along with filter response curves.
# To be compiled with python 2.7


# Import necessary libraries
import sys
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.ticker import *


# Define dictionaries for quick reference
dict_col={"0":'r-',
          "1":'y-',
          "2":'g-',
          "3":'c-',
          "4":'b-',
          "5":'m-'}
dict_age={"0":"age=0.1Gyr",
          "1":"age=0.3Gyr",
          "2":"age=0.7Gyr",
          "3":"age=1.1Gyr",
          "4":"age=2.0Gyr",
          "5":"age=3.0Gyr"}


# Input redshift, scaling options, and Lyman/Balmer break options
while True:
    try:
        z=raw_input("Enter redshift: ")
        z=float(z)
        if z<0:
            print "*** ERROR: Redshift must be non-negative. ***"
        elif z>25:
            print "*** ERROR: Redshift is too large. ***"
        else:
            break
    except ValueError: # If z cannot be converted into a float:
        print "*** ERROR: Input is not a number. ***"
while True:
    inp=raw_input("Enter log stellar mass of the galaxies (9/10)? ")
    if inp=="9": # Set reference to the galatic spectra with a stellar mass of 10^9 solar masses.
        dict={"0":"data/mass9_tau01_age01.spec",
              "1":"data/mass9_tau01_age03.spec",
              "2":"data/mass9_tau01_age07.spec",
              "3":"data/mass9_tau01_age11.spec",
              "4":"data/mass9_tau01_age20.spec",
              "5":"data/mass9_tau01_age30.spec",
              "6":"data/mass9_tau03_age01.spec",
              "7":"data/mass9_tau03_age03.spec",
              "8":"data/mass9_tau03_age07.spec",
              "9":"data/mass9_tau03_age11.spec",
              "10":"data/mass9_tau03_age20.spec",
              "11":"data/mass9_tau03_age30.spec",
              "12":"data/mass9_tau1_age01.spec",
              "13":"data/mass9_tau1_age03.spec",
              "14":"data/mass9_tau1_age07.spec",
              "15":"data/mass9_tau1_age11.spec",
              "16":"data/mass9_tau1_age20.spec",
              "17":"data/mass9_tau1_age30.spec"}
        break
    elif inp=="10": # Set reference to the galatic spectra with a stellar mass of 10^10 solar masses.
        dict={"0":"data/mass10_tau01_age01.spec",
              "1":"data/mass10_tau01_age03.spec",
              "2":"data/mass10_tau01_age07.spec",
              "3":"data/mass10_tau01_age11.spec",
              "4":"data/mass10_tau01_age20.spec",
              "5":"data/mass10_tau01_age30.spec",
              "6":"data/mass10_tau03_age01.spec",
              "7":"data/mass10_tau03_age03.spec",
              "8":"data/mass10_tau03_age07.spec",
              "9":"data/mass10_tau03_age11.spec",
              "10":"data/mass10_tau03_age20.spec",
              "11":"data/mass10_tau03_age30.spec",
              "12":"data/mass10_tau1_age01.spec",
              "13":"data/mass10_tau1_age03.spec",
              "14":"data/mass10_tau1_age07.spec",
              "15":"data/mass10_tau1_age11.spec",
              "16":"data/mass10_tau1_age20.spec",
              "17":"data/mass10_tau1_age30.spec"}
        break
    else:
        print "*** ERROR: Please only input 9 or 10. ***"
while True:
    sho=raw_input("Show Lyman break and Balmer break (y/N)? ")
    if sho=='y' or sho=='Y' or sho=="\'y\'" or sho=="\"y\"" or sho=="\'Y\'" or sho=="\"Y\"" or sho=="yes" or sho=="Yes" or sho=="YES":
        sho=1
    else:
        sho=0
    break


# Read the spectra.
spec_sto=[]
for j in range(18):
    fil=open(dict[str(j)],"r")
    dat=[]
    for lin in fil:
        dat.append(filter(None,lin.strip().split(' ')))
    fil.close()
    spec=[]
    record=False
    prev=0.
    for i in dat: # This reading process might seem weird, but the spectra files are generated by Le Phare, so I have to conform to their format.
        if record:
            if float(i[0])-prev<0.:
                break
            spec.append(i)
            prev=float(i[0])
        if i[0]=='8.00000':
            record=True
        if i[0][0:3]=='0.2':
            record=True
            spec.append(i)
            prev=float(i[0])
    spec_sto.append(spec)


# Read filters.log
try:
    fil=open("filters.log","r")
except:
    sys.exit("*** ERROR: Cannot find filters.log ***")
try:
    fil_log=[] # A 2D list that will store the information of filters.log
    for lin in fil:
        lin_raw=filter(None,lin.strip().split(' '))
#        print lin_raw
        if lin_raw[0][0]=='#' or lin_raw[0][0]=='-': # Ignore lines that start with '#' or '-'
            continue
        lin_raw[0]=int(lin_raw[0])
        lin_raw[-1]=float(lin_raw[-1])
        fil_log.append(lin_raw)
        if len(lin_raw)<3:
            sys.exit("*** ERROR: Cannot read filters.log, filter number " + lin_raw[0] + " is incomplete. ***")
    fil.close()
except:
    sys.exit("*** ERROR: Cannot read filters.log, please check for mistakes. ***")


# Read FILTER.RES, which is completely the same as used in HyperZ.
try:
    fil=open("FILTER.RES","r")
except:
    sys.exit("*** ERROR: Cannot find FILTER.RES ***")
try:
    fil_RES=[] # A 3D list that will store the information of FILTER.RES. fil_RES[i] represents the (i+1)-th filter.
    fil_len=[] # A 1D list that will store the length of each filter.
    fil_now=[]
    length=0
    for lin in fil:
        lin_raw=filter(None,lin.strip().split(' '))
        if lin_raw[0]=='#' or lin_raw[0]=='-': # Ignore lines that start with '#' or '-'
            continue
        lin_raw[0]=int(lin_raw[0])
        if length==0:
            fil_len.append(lin_raw[0])
            length=lin_raw[0]
        else:
            if len(lin_raw)!=3:
                sys.exit("*** ERROR: Cannot read FILTER.RES, there's some error in the " + str(len(fil_RES)+1) + "th filter. ***")
            lin_raw[1]=float(lin_raw[1])
            lin_raw[2]=float(lin_raw[2])
            fil_now.append(lin_raw[1:3])
            if lin_raw[0]==length:
                fil_RES.append(fil_now)
                fil_now=[]
                length=0
    fil.close()
except:
    sys.exit("*** ERROR: Cannot read FILTER.RES, please check for mistakes. ***")


# Prepare canvas
f,(ax1,ax2,ax3)=plt.subplots(1,3,sharex=True,sharey=True)
ax1.semilogx() # Declare logarithmic x-axes
ax2.semilogx()
ax3.semilogx()
tick_list=[100,300,600,1000,3000,6000,10000,30000,60000,100000,200000,300000] # Set positions of ticks and gridlines
grid_list=[i for i in range(100,1000,100)]+[i for i in range(1000,10000,1000)]+[i for i in range(10000,100000,10000)]+[100000,200000,300000]
tick_label=[str(i) for i in tick_list]
tit="z="+str(z)+", no extinction" # Set titles and labels
plt.suptitle(tit,size=20)
ax1.set_title("tau=0.1Gyr",size=20)
ax2.set_title("tau=0.3Gyr",size=20)
ax3.set_title("tau=1.0Gyr",size=20)
ax1.set_xlabel("Wavelength (Angstroms)",size=20)
ax2.set_xlabel("Wavelength (Angstroms)",size=20)
ax3.set_xlabel("Wavelength (Angstroms)",size=20)
ax1.set_ylabel("Magnitude (AB)",size=20)


# Set ticks, gridlines, and line styles for the x-axes
ax1.xaxis.set_major_locator(FixedLocator(tick_list))
ax1.xaxis.set_minor_locator(FixedLocator(grid_list))
for tic in ax1.xaxis.get_minor_ticks():
    tic.tick1On = tic.tick2On = False
ax1.xaxis.set_tick_params(width=3)
ax1.xaxis.set_major_formatter(FixedFormatter(tick_label))
plt.setp(ax1.get_xticklabels(),rotation=-30,ha='left')
ax1.xaxis.grid(b=True,which='minor',linestyle='-',alpha=0.2)

ax2.xaxis.set_major_locator(FixedLocator(tick_list))
ax2.xaxis.set_minor_locator(FixedLocator(grid_list))
for tic in ax2.xaxis.get_minor_ticks():
    tic.tick1On = tic.tick2On = False
ax2.xaxis.set_tick_params(width=3)
ax2.xaxis.set_major_formatter(FixedFormatter(tick_label))
plt.setp(ax2.get_xticklabels(),rotation=-30,ha='left')
ax2.xaxis.grid(b=True,which='minor',linestyle='-',alpha=0.2)

ax3.xaxis.set_major_locator(FixedLocator(tick_list))
ax3.xaxis.set_minor_locator(FixedLocator(grid_list))
for tic in ax3.xaxis.get_minor_ticks():
    tic.tick1On = tic.tick2On = False
ax3.xaxis.set_tick_params(width=3)
ax3.xaxis.set_major_formatter(FixedFormatter(tick_label))
plt.setp(ax3.get_xticklabels(),rotation=-30,ha='left')
ax3.xaxis.grid(b=True,which='minor',linestyle='-',alpha=0.2)


# Set ticks, gridlines, and line styles for the y-axes
ax1.yaxis.set_major_locator(MultipleLocator(1))
ax1.yaxis.set_minor_locator(AutoMinorLocator(2))
ax1.yaxis.set_tick_params(width=2)
ax1.yaxis.grid(b=True,which='major',linestyle='-',alpha=0.2)
plt.setp(ax2.get_yticklabels(), visible=True)
ax2.yaxis.set_tick_params(width=2)
ax2.yaxis.grid(b=True,which='major',linestyle='-',alpha=0.2)
plt.setp(ax3.get_yticklabels(), visible=True)
ax3.yaxis.set_tick_params(width=2)
ax3.yaxis.grid(b=True,which='major',linestyle='-',alpha=0.2)


# Plot filter response curves
try:
    for i in fil_log:
        xs=[]
        ys=[]
        for j in range(fil_len[i[0]-1]):
            xs.append(fil_RES[i[0]-1][j][0])
            ys.append(fil_RES[i[0]-1][j][1])
        tmp=max(ys)
        for j in range(len(ys)):
            ys[j]=ys[j]*-4/tmp+i[-1] # Normalize response function, enlarge 3 times and then add sensitivity
        if len(i)==3:
            nam=' '.join(i[1:-1])
        else: # Auto split line if possible
            nam1=' '.join(i[1:len(i)/2])
            nam2=' '.join(i[len(i)/2:-1])
            nam=nam1+"\n"+nam2
        ax1.plot(xs,ys,'k-',zorder=32)
        ax1.annotate(nam,xy=(xs[len(xs)/2],i[-1]),xytext=(0,0),textcoords='offset points',ha='center',va='top',zorder=32) # Annotate
        ax2.plot(xs,ys,'k-',zorder=32)
        ax2.annotate(nam,xy=(xs[len(xs)/2],i[-1]),xytext=(0,0),textcoords='offset points',ha='center',va='top',zorder=32)
        ax3.plot(xs,ys,'k-',zorder=32)
        ax3.annotate(nam,xy=(xs[len(xs)/2],i[-1]),xytext=(0,0),textcoords='offset points',ha='center',va='top',zorder=32)
except:
    sys.exit("*** ERROR: Cannot read filter.in, please check for mistakes. ***")


# Numerically calculate luminosity distance using flat universe, H0=67.8, Omega_M=0.3, Omega_vac=0.7
# Formula: D = (1+z) * c/H0 * Integrate( da / (a*sqrt(0.3/a+0.7*a^2)) ) from 1/(1+z) to 1
xs=np.linspace(1.0/(1+z),1,10000) # xs = discrete bins of da from 1/(1+z) to 1
ys=[1.0/(x*np.sqrt(0.3/x+0.7*x*x)) for x in xs] # ys = 1 / (a*sqrt(0.3/a+0.7*a^2))
dis=np.trapz(ys,xs) # Perform integration
dis*=(1+z)*3.0e8/67800 # Multiply with those constants. Now dis = luminosity distance (in Mpc)
dis_z2=16054.9275104 # Precalculated luminosity distance of redshift = 2


# Account for the effect of wavelength redshift on the magnitudes, which are in units of Hz^-1


# Plot spectra
xs=[]
ys=[]
for j in range(0,6):
    xs=[]
    ys=[]
    for i in spec_sto[j]:
        i[0]=float(i[0])
        i[1]=float(i[1])
        xs.append(i[0]/3*(1+z)) # Account for the wavelength redshift
        ys.append(i[1]+5*np.log10(dis/dis_z2)-2.5*np.log10((1.+z)/3)) # Account for the luminosity distance: delta_mag = 5*log(D), and account for that the magnitude is defined in unit frequency instead of wavelength.
    ax1.plot(xs,ys,dict_col[str(j%6)],linewidth=2.0,label=dict_age[str(j%6)])
l1=ax1.legend(bbox_to_anchor=(1.03,0.28))
l1.get_frame().set_linewidth(0.0)
l1.get_frame().set_alpha(0.4)
l1.set_zorder(36)
for j in range(6,12):
    xs=[]
    ys=[]
    for i in spec_sto[j]:
        i[0]=float(i[0])
        i[1]=float(i[1])
        xs.append(i[0]/3*(1+z)) # Account for the wavelength redshift
        ys.append(i[1]+5*np.log10(dis/dis_z2)-2.5*np.log10((1.+z)/3)) # Account for the luminosity distance: delta_mag = 5*log(D), and account for that the magnitude is defined in unit frequency instead of wavelength.
    ax2.plot(xs,ys,dict_col[str(j%6)],linewidth=2.0,label=dict_age[str(j%6)])
l2=ax2.legend(bbox_to_anchor=(1.03,0.28))
l2.get_frame().set_linewidth(0.0)
l2.get_frame().set_alpha(0.4)
l2.set_zorder(36)
for j in range(12,18):
    xs=[]
    ys=[]
    for i in spec_sto[j]:
        i[0]=float(i[0])
        i[1]=float(i[1])
        xs.append(i[0]/3*(1+z)) # Account for the wavelength redshift
        ys.append(i[1]+5*np.log10(dis/dis_z2)-2.5*np.log10((1.+z)/3)) # Account for the luminosity distance: delta_mag = 5*log(D), and account for that the magnitude is defined in unit frequency instead of wavelength.
    ax3.plot(xs,ys,dict_col[str(j%6)],linewidth=2.0,label=dict_age[str(j%6)])
l3=ax3.legend(bbox_to_anchor=(1.03,0.28))
l3.get_frame().set_linewidth(0.0)
l3.get_frame().set_alpha(0.4)
l3.set_zorder(36)


#Set axes range
xmin=600*(1+z)
xmax=15000*(1+z)
plt.xlim(xmin,xmax)
ymin=20.5
ymax=33.0
plt.ylim(ymax,ymin)


#Plot Lyman/Balmer break
if (sho):
    ax1.plot([912*(1+z),912*(1+z)],[-100,100],'k--',linewidth=1)
    ax1.plot([1216*(1+z),1216*(1+z)],[-100,100],'k--',linewidth=1)
    ax1.plot([3646*(1+z),3646*(1+z)],[-100,100],'k--',linewidth=1)
    ax1.annotate("912A",xy=(912*(1+z),ymin+1),xytext=(-1,0),textcoords='offset points',ha='right',va='top')
    ax1.annotate("1216A",xy=(1216*(1+z),ymin+1),xytext=(4,0),textcoords='offset points',va='top')
    ax1.annotate("3646A",xy=(3646*(1+z),ymin+1),xytext=(4,0),textcoords='offset points',va='top')
    ax2.plot([912*(1+z),912*(1+z)],[-100,100],'k--',linewidth=1)
    ax2.plot([1216*(1+z),1216*(1+z)],[-100,100],'k--',linewidth=1)
    ax2.plot([3646*(1+z),3646*(1+z)],[-100,100],'k--',linewidth=1)
    ax2.annotate("912A",xy=(912*(1+z),ymin+1),xytext=(-1,0),textcoords='offset points',ha='right',va='top')
    ax2.annotate("1216A",xy=(1216*(1+z),ymin+1),xytext=(4,0),textcoords='offset points',va='top')
    ax2.annotate("3646A",xy=(3646*(1+z),ymin+1),xytext=(4,0),textcoords='offset points',va='top')
    ax3.plot([912*(1+z),912*(1+z)],[-100,100],'k--',linewidth=1)
    ax3.plot([1216*(1+z),1216*(1+z)],[-100,100],'k--',linewidth=1)
    ax3.plot([3646*(1+z),3646*(1+z)],[-100,100],'k--',linewidth=1)
    ax3.annotate("912A",xy=(912*(1+z),ymin+1),xytext=(-1,0),textcoords='offset points',ha='right',va='top')
    ax3.annotate("1216A",xy=(1216*(1+z),ymin+1),xytext=(4,0),textcoords='offset points',va='top')
    ax3.annotate("3646A",xy=(3646*(1+z),ymin+1),xytext=(4,0),textcoords='offset points',va='top')


#Show
plt.show()